## A QR code based distributed anonymous credential application. 
***
For further details, please refer to the [full](https://github.com/Yue-Zhou1/zk-qrcode/blob/master/zk_qrcode_full.pdf) version of the project manuscript.
#### Consider a scenario where the user interacts with the service provider by displaying or scanning a QR code on their mobile phone, which contains the identity proof and the service request. 

Our approach utilizes a two-step verification process, encompassing both user identity authentication and the validation of specific required associated information. Together with these components, we develop an effective solution to support privacy-preserving QR code verification, as illustrated at a low level in Figure a, as well as a high level idea of our solution in the Figure b below. Fig c illustrates a QR code from the user who is entering a pub to verify he has a valid credential and is over 18 years old. The QR code has error correction level L (Low), and contains a zero-knowledge proof generated by Plonk plus other insensitive necessary information. For the access criteria proven QR code, it embeds the Plonk range proofs. It contains important information shows below:

- **Transcript**: The required *transcript* for Plonk includes the commitments, which are actually points(a pair of value x, y) on the elliptic curve, along with several field elements required to complete the verification process.
- **Protocol name**: e.g. *Plonk*. The application is able to support variable protocols.
- **Curve name**: e.g. *bn128*. The application is able to support variable curves if the curve is compatible with use on a smart contract.
- **Public signal**: the public parameters if available.


 > **a. An illustration of the foundational concept of converting a real-world problem into a zk-SNARK proof within the ${\tt zk\text{-}qrcode}$ framework shows below**
![lowlevel](https://github.com/user-attachments/assets/01d3ad5a-214c-42f9-a528-447094f6a39b)


 > **b. An illustration of our solution for privacy-preserving access criteria in-person verification via QR code shows below**
![workflow](https://github.com/user-attachments/assets/ec1edf33-b29c-4339-a3e0-5d6a65d764f3)

 > **c. An example QR code containing Plonk age proof information generated by the user before entering a bar**
 ![ageproof](https://github.com/user-attachments/assets/d521c8bc-1d97-42f1-9603-50a6f6c12743)

---
We implement our smart contract in Solidity and deploy our contract on the test Ethereum network, set the security parameter $\lambda = 128$. Plonk proof was constructed over alt-BabyJubjub BN128 elliptic curve. We use the Poseidon hash function to generate the challenges. 

External libaries and tools used to construct this demo application:
+ [snark.js](https://github.com/iden3/snarkjs): Generate zero-knowledge proof(Groth16, Plonk...)
+ [MongoDB](https://www.mongodb.com/): Free cloud database
+ [Expo](https://expo.dev/): For multiple platform test

## Runtime setup

1. Copy `.env.example` to `.env` and fill in database/zk paths.
2. Install backend dependencies:
   - `npm install`
3. Start backend in TypeScript dev mode:
   - `npm run dev`
4. Build and run production bundle:
   - `npm run build`
   - `npm run start:prod`

### Mobile app setup

1. Copy `mobile/.env.example` to `mobile/.env`.
2. Set `EXPO_PUBLIC_API_URL` to the backend address reachable by your device/emulator.
3. Install and run:
   - `cd mobile && npm install`
   - `npm run start`

## API routes

- New versioned routes:
  - `POST /api/v1/proofs`
  - `POST /api/v1/proofs/verify`
  - `POST /api/v1/identity-qr`
  - `POST /api/v1/identity-qr/verify`
- Legacy routes are still supported for backward compatibility:
  - `/cp`, `/vp`, `/cmt`, `/vmt`

## Build and deployment size

- Backend now supports minified bundling with `esbuild`:
  - `npm run build`
  - output: `dist/server.js`
- Mobile/web builds already use Expo/Metro bundling and minification.
  - For this project, adding webpack is not necessary; Metro is the modern default for Expo.

## Reproducing ZK runtime files

The app runtime requires these files:
- `controllers/circuit.wasm`
- `controllers/circuit_final.zkey`
- `controllers/verification_key.json`

Heavy zk setup/intermediate artifacts are intentionally untracked. To regenerate runtime files from source:

1. Ensure prerequisites are installed:
   - `circom` CLI
   - Node.js/npm (for `npx snarkjs`)
2. Run:
   - `./scripts/zk/reproduce-runtime-artifacts.sh`

Circuit source is kept in repo at `controllers/circuit.circom` for reproducibility.
